CSC 335 Project 2
Aidan Pieper

1. In Project 1 you noticed that when you removed the splhigh() call from the linked_list_test_adder() function the
console output of the threads interleaved to produce nonsensical output.  This is because kprintf is not currently
thread safe.

  A) Examine the code for kprintf. It uses two synchronization mechanisms for making its console output atomic --
  what are they?

    kprintf uses both normal mutual exclusion locks and spinlocks.

  B) Why might the kernel use two different mechanisms to protect console output?

    One of the mechanisms is used while the OS is in the process of setting up parts required for more complicated
    subsystems. For example, kprintf uses spinlocks before the OS can call printf_boostrap which sets up the normal
    mutex lock.

  C) Which of the two synchronization mechanisms is the kernel using when the interleaved output is produced by running
  your thread tests?

    The kernel is using the normal mutual exclusion locks.

  D) Explain why, despite this, the output is still interleaving.  (You are going to fix this later.)

    Normal mutual exclusion locks (struct lock) are not implemented yet in OS/161. Although kprintf is calling
    lock_acquire() and lock_release(), they are currently NOP methods so no syncronization is happening and interleaving
    still occurs.


2. Identify two other subsystems of the kernel that use synchronization mechanisms.  For each of these subsystems:

  A) Briefly describe the purpose of the subsystem.

    1. emu.c: This provides a unified filesystem interface for the emulator hardware running on sys161.
    2. console.c: This provides an interface for I/O operations for a generic device.

  B) Which synchronization mechanisms do they use?

    1. emu.c uses both mutex locks and semaphores.
    2. console.c uses mutex locks.

  C) For what purpose?

    1. emu.c uses semaphores for managing interrupts and mutex locks for controlling reads and writes to the filesystem.
    2. console.c uses mutex locks for controlling reading and writing.

  D) Are these subsystems afflicted by the same problem as kprintf?

    1. Yes, since emu.c uses mutex locks which are not implemented yet.
    2. Yes, since console.c mutex locks which are not implemented yet.


3. Locate the implementation of semaphores in src/kern/thread/synch.c.  Observe that they are implemented on top of wait
channels and spinlocks.

  A) Locate the definition of the struct semaphore.  In prose, explain the purpose of each of its attributes.  What
  does volatile mean here?

    TODO

  B) In prose, explain the purpose of every line of the function sem_create().

    TODO

  C) In P, notice that the wait channel is locked before the spinlock is released.  Can this cause deadlock?  Explain
  why or why not.

    TODO

4. Locate the implementation of wait channels in OS/161.  Examine all the functions in this implementation.

  A) Why are spinlocks used in the function that checks whether a wait channel is empty?

    TODO

  B) Which function is responsible for putting threads to sleep?  This function make an assumption about the state of
  the thread -- what is it?  This function also makes an important assumption about the state of the wait channel --
  what is it?  (To determine this look at the places this function is called from and into the function it calls.)

    TODO

  C) Look at the implementation of spinlocks, wait channels and P() of semaphores.  During what portion of the code are
  interrupts disabled?

    TODO